/**
 * Most basic implementation of the required types for DWN, as described in spec.
 * 
 * SPEC: https://identity.foundation/decentralized-web-node/spec/
 * Date of copy: 02.08.2022;
 */

type DID = string; // TODO: define a DID

/**
 * Spec: https://identity.foundation/decentralized-web-node/spec/#messages
 * 
 * 1. Message objects MAY contain a data property
 *      if present its value MUST be a base64Url encoded string of the Message’s data
 * 2. Message objects MUST contain a descriptor property
 *     its value MUST be an object composed as follows:
 * 
 *     2.1.     The object MUST contain a nonce property
 *                  its value MUST be a cryptographically random string that ensures each object is unique.
 *     2.2.     The object MUST contain a method property
 *                  its value MUST be a string that matches a Decentralized Web Node Interface method.
 *     2.3.     If the Message has data associated with it, passed directly via the data property of the Message or an external channel (e.g. IPFS fetch)
 *                  the descriptor object MUST contain a dataCid property
 *                  its value MUST be the stringified Version 1 CID of the DAG PB encoded data.
 *     2.4      If the Message has data associated with it, passed directly via the data property of the Message object or through a channel external to the message object,
 *                  the descriptor object MUST contain a dataFormat property
 *                  its value MUST be a string that corresponds with a registered IANA Media Type data format
 *                  (the most common being plain JSON, which is indicated by setting the value of the dataFormat property to application/json)
 *                  or one of the following format strings pending registration:
 *     2.4.1    application/vc+jwt - the data is a JSON Web Token (JWT) [RFC7519] formatted variant of a W3C Verifiable Credential.
 *     2.4.2    application/vc+ldp - the data is a JSON-LD formatted W3C Verifiable Credential.
 */

/**
 * TODO: 
 * 1. type Interface method
 * 2. type  Version 1 CID
 * 3. type IANA Media Type
 * 
 * Need validator for dataCid and dataFormat.
 *  they are required if data is present.
 */
type Descriptor = {
    nonce: string; // MUST be a cryptographically random string that ensures each object is unique.
    method: string; // MUST be a string that matches a Decentralized Web Node Interface method.
    dataCid?: string; // MUST be the stringified Version 1 CID of the DAG PB encoded data.
    dataFormat?: string; // MUST be a string that corresponds with a registered IANA Media Type data format.

    // In spec, but not in description of message object.
    schema?: string; // TODO: find in spec. can be url;
    threadId?: string; // TODO: find in spec, looks like UUID v4
    dateCreated?: number; // TODO: find in spec, not sure what type
};

/**
 * Spec is inconsistent, example does not match description.
 * 
 * TODO: implement JWS spec
 * TODO: implement JWE spec
 * 
 * Dummy type for now
 */
type JWS = any;
type JWE = any;

type Attestation = JWS;

type Authorization = JWS;

type MessageRequest = {
    data: string; // TODO: type base64Url encoded string
    descriptor: Descriptor;
    attestation?: Attestation;
    authorization?: Authorization;
};


/**
 * Construct the Request Object:
 * 
 * Create a JSON object for the request.
 * 1. The Request Object MUST include a 'target' property
 *      and its value MUST be the Decentralized Identifier base URI of the DID-relative URL.
 * 2. The Request Object MUST include a messages property,
 *      and its value MUST be an array composed of Message objects that are
 *      generated by parsing the DID-relative URL’s queries parameter value as a
 *      JSON array and performing the following steps for each entry:
 *      
 *  2.1 Construct a Message object.
 *  2.2 Set the descriptor property of the Message object
 *      to the entry, ensuring it is a valid Message Descriptor object.
 *  2.3 Augment the Message object with any signing and authorization values required,
 *      as described in the Messages section.
 *  2.4 Append the object to the Request Object’s messages array.
 */
type RequestObject =  {
    target: DID;
    messages: MessageRequest[];
};

/**
 * Response Objects:
 * 1.       The object MAY have a status property
 *              if an error is produced from a general request-related issue
 *              if present its value MUST be an object composed of the following properties:
 * 
 * 1.1      The status object MUST have a code property
 *              its value MUST be an integer set to the HTTP Status Code appropriate for the status of the response.
 * 1.2      The status object MAY have a detail property,
 *              if present its value MUST be a string that describes a terse summary of the status
 *              It is RECOMMENDED that the implementer set the message text to the standard title of the HTTP Status Code
 *              when a title/message has already been defined for that code.
 * 
 * 2.       The object MAY have a replies property
 *              if present its value MUST be an array containing Message Result Objects for all messages that were included in the initiating request object.
 *              The Message Result Objects MUST be put in the index order that matches the index of each result’s corresponding request message.
 *              Message Result Objects are constructed as follows:
 * 2.1      The object MUST have a status property
 *              its value MUST be an object composed of the following properties
 * 2.1.1    same as 1.1
 * 2.1.2    same as 1.2
 * 2.2.     The object MAY have a entries property if the message request was successful
 *             If present, its value MUST be the resulting message entries returned from the invocation of the corresponding message.
 */

type Status = {
    code: number; // HTTP code
    detail?: string; // if present its value MUST be a string that describes a terse summary of the status
}

type MessageEntries = any; // TODO: Type this, find in spec

type MessageResult = {
    status: Status;
    entries?: MessageEntries[];
};

type ResponseObject =  {
    status?: Status;
    replies?: MessageResult[];
};